#Voici toute la partie que j'ai faite, il y a un tetros (couleur et forme aléatoire) qui tombe à chaque fois que l'ancient a fini de tomber et il y a le debut des mouvements avec gauche et droite mais il y a encore bcp de pbl à resoudre


import pygame
from pygame.locals import *
from math import ceil
from random import randint
import sys

clock = pygame.time.Clock()

Lposition_bloc_x=[]  #Voici les listes des position des blocs, et un bloc sera assigné a une valeur
Lposition_bloc_y=[]
Lcouleur_bloc=[]
Lposition_carre_x=[]
Lposition_carre_y=[]

#Ici, se trouve la grande liste qui contient 10 petites listes de 18 false (car les cases sont vides)
Lposition_cadrillage_x=[]
for i in range(10):
    Lposition_cadrillage_x.append([])
    for j in range(18):
        Lposition_cadrillage_x[i].append(False)







nombre_bloc=0   #Déini, le debut du jeu, au début y'a 0 bloc, il faut en créer 1 et comme y'en a 0 bloc le type est 0
doit_cree_bloc=1  #Ici, si marque 1, tout comme normal mais si marque 17, va afficher la liste des blocs  
type_bloc=0
liste_bloc_x=-150  #La, ajoute cette valeur aux positions des blocs en x (aussi pour + tard)
liste_bloc_y=-300  #La, ajoute cette valeur aux positions des blocs en y mais est pas encore utilisé
color=""
bloc_tetris=0 
repetition=49

def definition():
        
    """ def :
    liste :
    
    Lposition_bloc_x = reference la position x de touts les blocs crées en pixel
    Lposition_bloc_y = reference la position y de touts les blocs crées en pixel
    Lcouleur_bloc = reference la couleur d'un tetros (groupe de 4 bloc) grâce à un chiffre, qui correspond donc à une couleur
    Lposition_carre_x = reference la position en terme de bloc et non de pixel
    Lposition_carre_y = reference la position en terme de bloc et non de pixel
    Lposition_cadrillage_x = la grande liste de 10 liste de 18 elements
    
    variables :
    
    liste_bloc_x = permet d'ajouter cette valeur a la position des blocs
    liste_bloc_y = de même mais avec y au lieu de x
    nombre_bloc = permet de savoir combient de bloc sont crées
    doit_cree_bloc = permet de creer x bloc, x etant la valeur de : doit_cree_bloc
    type_bloc = permet de savoir quelle sera le motif de bloc parmis 7 choix
    color = ici va mettre d'abord la couleur du carre de jeu puis du cadrillage
    repetition = sert a colorier une ligne rose tt les 30 pixels, comme ça pas oblige de redessiner le quadrillage à chaque fois
    """
    print("ici")
    
    
def couleur_bloc(i): 
    
    """ Ici, la variable permet de prendre un bloc de couleur et de l'importe, donc permet de determiner la couleur 
    d'un tetros grâce à la liste Lcouleur_bloc qui va append un chiffre correspondant à une couleur. La variable prend 
    en paramètre i, ce qui va permettre la repetition pour x, x etant le nombre de bloc du tetros crée"""

    if Lcouleur_bloc[i]==1:
        image = pygame.image.load("python_tetris/bloc_tetris_vert.jpg")   #ça importe la photo, ou image= la photo
        bloc_tetris = pygame.transform.scale(image, (50, 50))   
    elif Lcouleur_bloc[i]==2:
        image = pygame.image.load("python_tetris/bloc_tetris_rouge.jpg")  
        bloc_tetris = pygame.transform.scale(image, (50, 50))      
    elif Lcouleur_bloc[i]==3:
        image = pygame.image.load("python_tetris/bloc_tetris_bleu.jpg")  
        bloc_tetris = pygame.transform.scale(image, (50, 50))      
    elif Lcouleur_bloc[i]==4:
        image = pygame.image.load("python_tetris/bloc_tetris_orange.jpg")  
        bloc_tetris = pygame.transform.scale(image, (50, 50))                 
    elif Lcouleur_bloc[i]==5:
        image = pygame.image.load("python_tetris/bloc_tetris_violet.jpg")  
        bloc_tetris = pygame.transform.scale(image, (50, 50))        
    else :
        image = pygame.image.load("python_tetris/bloc_tetris_jaune.jpg")  
        bloc_tetris = pygame.transform.scale(image, (50, 50))     
    return bloc_tetris

def color(x):
    ok=False
    while ok==False :
        ok=True
        color=str(input(x))
        if color == "rouge":
            color=(255,0,0)
        elif color == "jaune":
            color=(255,255,0)
        elif color == "vert":
            color=(0,255,0)
        elif color == "bleu":
            color=(0,0,255)
        elif color == "blanc":
            color=(255,255,255)
        elif color == "noir":
            color=(0,0,0)
        elif color == "magenta":
            color=(255,0,255)
        else :
            print("Met une couleur sans majuscule et parmis ce choix : rouge ; vert ; jaune ; bleu ; blanc ; noir ; magenta et reessaie")
            ok=False
    return color
    
    

def crea_map(color):
    """Ici, crée la map"""
    for i in range(100,650,50) :
        pygame.draw.line(window  ,color , (i,50),(i,950))
    for u in range (50,1000,50):
        pygame.draw.line(window  , color, (100,u),(600,u))
        pygame.display.flip()


def creation_bloc(nombre_bloc,bloc_tetris):
    
    """Ici, la def creation_bloc va crée grâce à la commande window.blit un bloc tetris a la position des liste : Lposition_bloc_x et celle y
    .De plus, il repète ce processus nombre_bloc fois. Il prend en paramètre nombre_bloc"""
    
    for i in range(nombre_bloc):
        bloc_tetris=couleur_bloc(i)
        window.blit(bloc_tetris,[Lposition_bloc_x[i],Lposition_bloc_y[i]])  # Ici, va print cette image a la position x,y
        
        Lposition_carre_x[i]=(ceil(Lposition_bloc_x[i]/50)-1)
        Lposition_carre_y[i]=(ceil(Lposition_bloc_y[i]/50)-1) #insère dans la liste la position des blocs en terme de bloc pas pixel

    
def type_bloc_image(doit_cree_bloc,nombre_bloc,type_bloc,liste_bloc_x,liste_bloc_y):  
    
    """ Ici, type_bloc_image va choisir aléatoirement un type de bloc et va ajouter a la liste Lposition_bloc_x et y les valeurs
    précisent pour cree ce bloc, mais ici on ajoute juste les valeurs a la liste, on ne cree pas les blocs. Elle prend en compte :
    doit_cree_bloc,type_bloc,liste_bloc_x"""
    
    if doit_cree_bloc>=1 and doit_cree_bloc<10:      #Dès que doit_cree_bloc >0, on ajoute et cree un bloc
        type_bloc=randint(1,7)  #pour la creation du bloc aléaotire
        doit_cree_bloc-=1
        couleur_bloc=randint(1,6)

        for i in range(4):
            Lposition_carre_x.append(0)
            Lcouleur_bloc.append(couleur_bloc)
            Lposition_carre_y.append(0)    
    
    if doit_cree_bloc>=10:
        type_bloc=doit_cree_bloc-10
        doit_cree_bloc-=1
    
    if type_bloc==1:  #Ici, c'est un bloc 4X1
        Lposition_bloc_x.append(400+liste_bloc_x)  #Ici va ajoouter aux liste des valeur et comme ça,
        Lposition_bloc_y.append(350+liste_bloc_y)  # le bloc va aller à ces valeurs
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        Lposition_bloc_x.append(550+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                 # Ici, comme ajoute 4, va dessiner 4 blocs
        type_bloc=0
    
    if type_bloc==2:   # Ici, c'est le bloc 3X1 avec un bloc  en bas a droite
        Lposition_bloc_x.append(400+liste_bloc_x)  
        Lposition_bloc_y.append(400+liste_bloc_y) 
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                
        type_bloc=0
        
    if type_bloc==3:   # Ici, c'est le bloc 3X1 avec un bloc en bas a gauche
        Lposition_bloc_x.append(400+liste_bloc_x) 
        Lposition_bloc_y.append(400+liste_bloc_y)  
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(400+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                 
        type_bloc=0
    
    if type_bloc==4:   #Ici c'est le carré
        Lposition_bloc_x.append(400+liste_bloc_x) 
        Lposition_bloc_y.append(400+liste_bloc_y)  
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(400+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                 
        type_bloc=0
    
    if type_bloc==5:    #Ici c'est le bloc 2 en haut et 2 en bas à droite
        Lposition_bloc_x.append(400+liste_bloc_x) 
        Lposition_bloc_y.append(400+liste_bloc_y)  
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                 
        type_bloc=0
        
    if type_bloc==6:    #Ici c'est le bloc 2 en haut et 2 en bas à droite
        Lposition_bloc_x.append(450+liste_bloc_x) 
        Lposition_bloc_y.append(400+liste_bloc_y)  
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(400+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                 
        type_bloc=0
    
    if type_bloc==7:    #Ici c'est le bloc T
        Lposition_bloc_x.append(400+liste_bloc_x) 
        Lposition_bloc_y.append(400+liste_bloc_y)  
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(500+liste_bloc_x)
        Lposition_bloc_y.append(400+liste_bloc_y)
        Lposition_bloc_x.append(450+liste_bloc_x)
        Lposition_bloc_y.append(350+liste_bloc_y)
        nombre_bloc+=4                 
        type_bloc=0
    if doit_cree_bloc>=10:
        liste_bloc_x+=150
    return nombre_bloc,doit_cree_bloc,liste_bloc_x
    
def faire_tomber(nomre_bloc,doit_cree_bloc,repetition,color1,color2,nombre_bloc):
    
    doit_cree_bloc=doit_cree_bloc

    #Ici, va soit tou reset si bloc touche le bout ou trouve un bloc en dessous, ou alors va ajouter 1 a la position du bloc et donc il va descendre
    if max(Lposition_carre_y)==18   or Lposition_cadrillage_x[Lposition_carre_x[0]-1][Lposition_carre_y[0]+0]==True  or Lposition_cadrillage_x[Lposition_carre_x[1]-1][Lposition_carre_y[1]+0]==True  or Lposition_cadrillage_x[Lposition_carre_x[2]-1][Lposition_carre_y[2]+0]==True  or Lposition_cadrillage_x[Lposition_carre_x[3]-1][Lposition_carre_y[3]+0]==True : 
            
        if repetition==0:   #reset pour la suite
            for i in range (4):
                
                Lposition_cadrillage_x[Lposition_carre_x[i]-1][Lposition_carre_y[i]-1]=True
            Lposition_bloc_x.clear()
            Lposition_bloc_y.clear()
            Lcouleur_bloc.clear()
            repetition=49
            doit_cree_bloc+=1
            nombre_bloc-=4
    else :    
        repetition+=1
        
        for i in range(4):   #Ici, dessine pour effacer l'ancient tetros et garder le fond color1
            
            pygame.draw.rect(window, color1, (Lposition_bloc_x[len(Lposition_bloc_y)-1-i]+1, Lposition_bloc_y[len(Lposition_bloc_y)-1-i], 49, 1))
            pygame.draw.rect(window, color2, (Lposition_bloc_x[len(Lposition_bloc_y)-1-i], Lposition_bloc_y[len(Lposition_bloc_y)-1-i], 1, 1))
            Lposition_bloc_y[len(Lposition_bloc_y)-1-i]+=1
            
            if repetition==50: #Va dessiner une ligne de la couleur du cadrillage tout les 50 pixels
                
                pygame.draw.rect(window, color2, (Lposition_bloc_x[len(Lposition_bloc_y)-1-i]+1, Lposition_bloc_y[len(Lposition_bloc_y)-1-i]-1, 49, 1))
                
        if repetition == 50 :  #reset
            repetition = 0
            
    return doit_cree_bloc,repetition,nombre_bloc

def mouvement():

    """Ici, va deplacer le tetros si appuie sur la touche gauche et droite mais c'est pas encore fini et je laisse qui veux la continuer """
    
    for event in pygame.event.get():
        if event.type == KEYDOWN :
            if event.key == K_RIGHT :
                for i in range(4):
                    Lposition_bloc_x[len(Lposition_bloc_x)-1-i]+=50
            if event.key == K_LEFT :
                for i in range(4):
                    Lposition_bloc_x[len(Lposition_bloc_x)-1-i]-=50
    

def jeu(doit_cree_bloc,nombre_bloc,type_bloc,liste_bloc_x,bloc_tetris,liste_bloc_y):
    
    """ def, de base permet de lancer le jeu avec la creation des blocs et de la map"""
    
    
    nombre_bloc,doit_cree_bloc,liste_bloc_x=type_bloc_image(doit_cree_bloc,nombre_bloc,type_bloc,liste_bloc_x,liste_bloc_y)
    
    bloc_tetris=creation_bloc(nombre_bloc,bloc_tetris)
    
    return nombre_bloc,doit_cree_bloc,liste_bloc_x    
    
def quit_game():
    
    """ Permet de fermer la page si appuye sur la croix """
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()        
            

pygame.init()   #Début de la création de la page

color1=color("Tu veux quelle couleur pour l'écran ?")
color2=color("Tu veux quelle couleur pour les lignes ?")

window = pygame.display.set_mode((700,1000))  #crée le rectangle noir de 700 par 1000
pygame.draw.rect(window, color1, pygame.Rect(100,50, 500, 900))  # ici cree le rectangle pour le jeu
crea_map(color2)

run = True
while run: 
    quit_game()
    
    nombre_bloc,doit_cree_bloc,liste_bloc_x=jeu(doit_cree_bloc,nombre_bloc,type_bloc,liste_bloc_x,bloc_tetris,liste_bloc_y)
    
    
    doit_cree_bloc,repetition,nombre_bloc=faire_tomber(nombre_bloc,doit_cree_bloc,repetition,color1,color2,nombre_bloc)
    
    mouvement()
        
    #window.fill((0,0,0))  # a quoi sa sert de tout effacer à chaque fois+couleur 0,0,0=noir

    pygame.display.update()
